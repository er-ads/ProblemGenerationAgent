======================================================================================================================================
TEST 0

{
  "word_problem": "A sturdy crate with a mass of 25.0 kg rests on a perfectly smooth factory floor. A lightweight rope is attached to the crate, passes over a frictionless, massless pulley, and then connects to a hanging weight of 15.0 kg. The system is released from rest. Assuming the acceleration due to gravity is 9.81 m/s^2, what is the average velocity of the crate during the first 5.0 seconds of its motion?",      
  "formula_ids": [
    "5_A",
    "2_E",
    "2_A"
  ],
  "variables": {
    "m1": {
      "value": 25.0,
      "unit": "kg"
    },
    "m2": {
      "value": 15.0,
      "unit": "kg"
    },
    "g": {
      "value": 9.81,
      "unit": "m/s^2"
    },
    "time_interval": {
      "value": 5.0,
      "unit": "s"
    },
    "average_velocity": {
      "value": "NaN",
      "unit": "m/s"
    }
  }
}
```
Validation Result: {'valid': True, 'unknown_var': 'average_velocity'}
Call 2 Completed----------------------------------------------------------------------------

import math

def calculate_net_force(mass: float, acceleration: float) -> float:
    return mass * acceleration

def calculate_average_velocity(final_position: float, initial_position: float, time_interval: float) -> float:
    if time_interval == 0:
        return float('inf')
    return (final_position - initial_position) / time_interval

def calculate_displacement_from_time(initial_velocity: float, acceleration: float, time: float) -> float:
    return (initial_velocity * time) + (0.5 * acceleration * time**2)

def solve():
    try:
        # Define known variables
        m1 = 25.0
        m2 = 15.0
        g = 9.81
        time_interval = 5.0

        # The system consists of m1 on a smooth horizontal surface and m2 hanging.
        # The net force acting on the entire system causing acceleration is due to m2.
        # F_net = m2 * g
        # The total mass being accelerated is M_total = m1 + m2.
        # From Newton's Second Law (represented by 5_A: F = ma), a = F_net / M_total.

        # Calculate the acceleration of the system
        # F_net_system = m2 * g
        # M_total_system = m1 + m2
        # acceleration = F_net_system / M_total_system
        acceleration = (m2 * g) / (m1 + m2)

        # The system is released from rest, so initial_velocity = 0.
        initial_velocity = 0.0

        # Calculate the displacement of the crate during the time interval using formula 2_E
        displacement = calculate_displacement_from_time(
            initial_velocity=initial_velocity,
            acceleration=acceleration,
            time=time_interval
        )

        # The crate starts at an initial position of 0.
        initial_position = 0.0
        final_position = displacement

        # Calculate the average velocity of the crate using formula 2_A
        average_velocity = calculate_average_velocity(
            final_position=final_position,
            initial_position=initial_position,
            time_interval=time_interval
        )

        return average_velocity
    except Exception as e:
        return None
Execution and Validation Result: {'valid': True, 'result': 9.196875}
Call 3 Completed----------------------------------------------------------------------------

==========================================================================================================================================
TEST 1A

{
  "word_problem": "An engineer is designing a funicular system to transport goods up an inclined track. A loaded cart with a mass of 25.0 kg is connected by a light, inextensible cable over a frictionless, massless pulley to a heavier counterweight of 40.0 kg. The track is inclined at an angle of 30.0 degrees with respect to the horizontal. There is kinetic friction between the cart and the track, with a coefficient of kinetic friction of 0.15. If the system starts from rest and accelerates for 10.0 seconds, what will be the final speed of the counterweight? Assume the acceleration due to gravity is 9.81 m/s\u00b2.",
  "formula_ids": ["5_A", "2_D", "2_E"],
  "variables": {
    "mass_m1": {
      "value": 25.0,
      "unit": "kg"
    },
    "mass_m2": {
      "value": 40.0,
      "unit": "kg"
    },
    "inclination_angle": {
      "value": 30.0,
      "unit": "degrees"
    },
    "coefficient_of_kinetic_friction": {
      "value": 0.15,
      "unit": "dimensionless"
    },
    "acceleration_due_to_gravity": {
      "value": 9.81,
      "unit": "m/s\u00b2"
    },
    "time_duration": {
      "value": 10.0,
      "unit": "s"
    },
    "final_speed_m2": {
      "value": "NaN",
      "unit": "m/s"
    }
  }
}
```
Validation Result: {'valid': True, 'unknown_var': 'final_speed_m2'}
Call 2 Completed----------------------------------------------------------------------------

import math

def calculate_net_force(mass: float, acceleration: float) -> float:
    return mass * acceleration

def calculate_final_velocity_from_time(initial_velocity: float, acceleration: float, time: float) -> float:
    return initial_velocity + (acceleration * time)

def calculate_displacement_from_time(initial_velocity: float, acceleration: float, time: float) -> float:
    return (initial_velocity * time) + (0.5 * acceleration * time**2)


def solve():
    try:
        # Define known variables
        mass_m1 = 25.0  # mass of the cart (kg)
        mass_m2 = 40.0  # mass of the counterweight (kg)
        inclination_angle_degrees = 30.0  # inclination angle of the track (degrees)
        coefficient_of_kinetic_friction = 0.15  # coefficient of kinetic friction (dimensionless)
        acceleration_due_to_gravity = 9.81  # acceleration due to gravity (m/s^2)
        time_duration = 10.0  # time duration for acceleration (s)

        # Convert inclination angle from degrees to radians for trigonometric functions
        inclination_angle_radians = math.radians(inclination_angle_degrees)

        # --- Step 1: Analyze forces on the cart (mass_m1) on the inclined track ---
        # Component of gravity perpendicular to the incline (for normal force)
        gravity_perp_m1 = mass_m1 * acceleration_due_to_gravity * math.cos(inclination_angle_radians)

        # Normal force on the cart
        normal_force_m1 = gravity_perp_m1

        # Kinetic friction force (opposes motion up the incline, so acts down the incline)
        friction_force_m1 = coefficient_of_kinetic_friction * normal_force_m1

        # Component of gravity parallel to the incline (pulls cart down the incline)
        gravity_parallel_m1 = mass_m1 * acceleration_due_to_gravity * math.sin(inclination_angle_radians)

        # --- Step 2: Calculate the net force acting on the entire system ---
        # The system consists of m1 (cart) and m2 (counterweight).
        # Assume m2 moves down and m1 moves up the incline, as m2 > m1.
        # Driving force from m2 (pulling down): mass_m2 * acceleration_due_to_gravity
        # Resisting forces on m1 (pulling down the incline): gravity_parallel_m1 + friction_force_m1

        net_driving_force = (mass_m2 * acceleration_due_to_gravity) - gravity_parallel_m1 - friction_force_m1

        # Total mass of the system that is accelerating
        total_mass = mass_m1 + mass_m2

        # Calculate the acceleration of the system using Newton's Second Law (F_net = M_total * a)
        # This is the conceptual application of formula 5_A (calculate_net_force), rearranged to solve for 'a'.
        # If net_driving_force is non-positive, the system might not accelerate in the assumed direction
        # or might not move at all if static friction were considered.
        # Given kinetic friction, we assume motion and calculate acceleration.
        if total_mass == 0:
            system_acceleration = 0.0  # Or handle as an error if appropriate
        else:
            system_acceleration = net_driving_force / total_mass

        # --- Step 3: Calculate the final speed of the counterweight ---
        # The system starts from rest, so initial velocity is 0.
        initial_velocity = 0.0

        # Use the kinematic formula (formula_id: 2_D) to find the final velocity
        final_speed_m2 = calculate_final_velocity_from_time(initial_velocity, system_acceleration, time_duration)

        # Return the computed answer
        return final_speed_m2
    except Exception as e:
        # Catch any potential errors during calculation (e.g., division by zero)
        print(f"An error occurred: {e}")
        return None
Execution and Validation Result: {'valid': True, 'result': 36.60247545512}
Call 3 Completed----------------------------------------------------------------------------


==========================================================================================================================================
TEST 2A

{
  "word_problem": "A 2.5 kg package starts from rest at the top of a ramp. It slides down a vertical height of 3.0 m. The ramp surface is frictionless. Upon reaching the bottom, the package moves onto a horizontal carpet. The coefficient of kinetic friction between the package and the carpet is 0.25. The package eventually comes to rest on the carpet. Assuming an acceleration due to gravity of 9.81 m/s\u00b2, how far does the package slide on the carpet before stopping?",
  "formula_ids": ["7_A", "6_A", "7_F"],
  "variables": {
    "mass": {
      "value": 2.5,
      "unit": "kg"
    },
    "height": {
      "value": 3.0,
      "unit": "m"
    },
    "coefficient_of_kinetic_friction": {
      "value": 0.25,
      "unit": "dimensionless"
    },
    "acceleration_due_to_gravity": {
      "value": 9.81,
      "unit": "m/s\u00b2"
    },
    "distance_on_carpet": {
      "value": "NaN",
      "unit": "m"
    }
  }
}

import math

def calculate_work_done_constant_force(force_magnitude: float, displacement_magnitude: float, angle_degrees: float) -> float:
    angle_radians = math.radians(angle_degrees)
    return force_magnitude * displacement_magnitude * math.cos(angle_radians)

def calculate_kinetic_friction(coefficient_of_kinetic_friction: float, normal_force: float) -> float:
    return coefficient_of_kinetic_friction * normal_force

def calculate_change_in_kinetic_energy(work_conservative: float, work_non_conservative: float, work_pseudo_force: float) -> float:
    return work_conservative + work_non_conservative + work_pseudo_force

def solve() -> float | None:
    try:
        # Define known variables
        mass = 2.5
        height = 3.0
        coefficient_of_kinetic_friction = 0.25
        acceleration_due_to_gravity = 9.81

        # --- Part 1: Package slides down the frictionless ramp ---
        # Initial kinetic energy at the top of the ramp (starts from rest)
        initial_kinetic_energy_ramp = 0.0

        # Calculate the work done by gravity (conservative force) as the package slides down.
        # The force of gravity is mass * acceleration_due_to_gravity.
        # The displacement in the direction of gravity is the vertical height.
        # The angle between force and displacement is 0 degrees (both downwards).
        work_conservative_gravity_ramp = calculate_work_done_constant_force(
            force_magnitude=mass * acceleration_due_to_gravity,
            displacement_magnitude=height,
            angle_degrees=0
        )

        # For the frictionless ramp, non-conservative work and pseudo-force work are zero.
        # Use the Work-Energy Theorem (7_F) to find the change in kinetic energy.
        delta_kinetic_energy_ramp = calculate_change_in_kinetic_energy(
            work_conservative=work_conservative_gravity_ramp,
            work_non_conservative=0.0,
            work_pseudo_force=0.0
        )

        # The final kinetic energy at the bottom of the ramp is the initial KE plus the change in KE.
        final_kinetic_energy_ramp = initial_kinetic_energy_ramp + delta_kinetic_energy_ramp

        # This final kinetic energy is the initial kinetic energy when the package moves onto the carpet.
        initial_kinetic_energy_carpet = final_kinetic_energy_ramp

        # --- Part 2: Package slides on the horizontal carpet ---
        # The package comes to rest on the carpet, so its final kinetic energy is zero.
        final_kinetic_energy_carpet = 0.0

        # Calculate the change in kinetic energy on the carpet.
        delta_kinetic_energy_carpet = final_kinetic_energy_carpet - initial_kinetic_energy_carpet

        # On a horizontal surface, the normal force equals the gravitational force (weight).
        normal_force_carpet = mass * acceleration_due_to_gravity

        # Calculate the force of kinetic friction acting on the package on the carpet.
        friction_force = calculate_kinetic_friction(
            coefficient_of_kinetic_friction=coefficient_of_kinetic_friction,
            normal_force=normal_force_carpet
        )

        # On the horizontal carpet, there is no change in gravitational potential energy,
        # so work done by conservative forces is 0.
        work_conservative_carpet = 0.0
        # There are no pseudo-forces mentioned.
        work_pseudo_force_carpet = 0.0

        # According to the Work-Energy Theorem (7_F) for the carpet:
        # delta_kinetic_energy_carpet = work_conservative_carpet + work_non_conservative_carpet + work_pseudo_force_carpet
        # delta_kinetic_energy_carpet = 0 + work_non_conservative_carpet + 0
        # So, the work done by non-conservative forces (friction) equals the change in kinetic energy.
        # work_non_conservative_carpet = delta_kinetic_energy_carpet

        # Also, the work done by friction can be expressed using formula 7_A:
        # work_non_conservative_carpet = calculate_work_done_constant_force(
        #     force_magnitude=friction_force,
        #     displacement_magnitude=distance_on_carpet, # This is the unknown we want to find
        #     angle_degrees=180 # Friction opposes motion, so the angle between force and displacement is 180 degrees.
        # )

        # Combining these, we get:
        # delta_kinetic_energy_carpet = friction_force * distance_on_carpet * math.cos(math.radians(180))
        # delta_kinetic_energy_carpet = -friction_force * distance_on_carpet

        # Solve for distance_on_carpet:
        distance_on_carpet = -delta_kinetic_energy_carpet / friction_force

        return distance_on_carpet
    except Exception as e:
        return None
Execution and Validation Result: {'valid': True, 'result': 12.0}



==========================================================================================================================================
TEST 3A

{
  "word_problem": "A small wooden block with a mass of 0.5 kg is placed on a horizontal turntable. The block is positioned 0.3 meters from the center of the turntable. If the coefficient of static friction between the block and the turntable surface is 0.6, and the acceleration due to gravity is 9.81 m/s², what is the maximum angular speed (in rad/s) the turntable can achieve before the block begins to slip?",
  "formula_ids": [
    "5_A",
    "8_E",
    "8_K"
  ],
  "variables": {
    "mass": {
      "value": 0.5,
      "unit": "kg"
    },
    "radius_of_path": {
      "value": 0.3,
      "unit": "m"
    },
    "coefficient_of_static_friction": {
      "value": 0.6,
      "unit": "unitless"
    },
    "acceleration_due_to_gravity": {
      "value": 9.81,
      "unit": "m/s\u00b2"
    },
    "angular_velocity": {
      "value": "NaN",
      "unit": "rad/s"
    }
  }
}


import math

def calculate_net_force(mass: float, acceleration: float) -> float:
    return mass * acceleration

def calculate_centripetal_acceleration(radius: float, linear_speed: float = None, angular_velocity: float = None) -> float:
    if radius == 0:
        return 0.0
    if linear_speed is not None:
        return linear_speed**2 / radius
    elif angular_velocity is not None:
        return angular_velocity**2 * radius
    else:
        raise ValueError("Must provide either linear_speed or angular_velocity")

def calculate_max_angular_velocity_platform(coefficient_of_static_friction: float, radius: float, gravity: float = 9.81) -> float:
    if radius == 0:
        return float('inf')
    return math.sqrt(coefficient_of_static_friction * gravity / radius)

def solve():
    try:
        # Define known variables
        mass = 0.5
        radius_of_path = 0.3
        coefficient_of_static_friction = 0.6
        acceleration_due_to_gravity = 9.81

        # The problem asks for the maximum angular speed before the block slips.
        # This can be directly calculated using calculate_max_angular_velocity_platform (formula 8_K).
        angular_velocity = calculate_max_angular_velocity_platform(
            coefficient_of_static_friction=coefficient_of_static_friction,
            radius=radius_of_path,
            gravity=acceleration_due_to_gravity
        )

        # Return the computed answer
        return angular_velocity
    except Exception as e:
        return None
Execution and Validation Result: {'valid': True, 'result': 4.4294469180700204}


==========================================================================================================================================
TEST 4A

{
  "word_problem": "An engineer is performing a dynamic analysis of a new robotic arm. The arm's movement can be simplified to a single axis for initial stability checks. It consists of three primary components:\n1.  The base joint and first link, with a mass of 5.5 kg, located at an effective position of 0.8 m from the arm's pivot, currently moving at 0.3 m/s and accelerating at 0.08 m/s^2.\n2.  The second link and its joint, with a mass of 12.0 kg, located at 2.5 m from the pivot, moving at -0.05 m/s (towards the pivot) and accelerating at -0.03 m/s^2.\n3.  The end-effector and third link, with a mass of 7.2 kg, located at 4.1 m from the pivot, moving at 0.15 m/s and accelerating at 0.01 m/s^2.\nAll positions, velocities, and accelerations are measured along the arm's operational axis. What is the acceleration of the center of mass of the entire robotic arm system?",
  "formula_ids": [
    "9_A",
    "9_K",
    "9_M"
  ],
  "variables": {
    "m1": {
      "value": 5.5,
      "unit": "kg"
    },
    "x1": {
      "value": 0.8,
      "unit": "m"
    },
    "v1": {
      "value": 0.3,
      "unit": "m/s"
    },
    "a1": {
      "value": 0.08,
      "unit": "m/s^2"
    },
    "m2": {
      "value": 12.0,
      "unit": "kg"
    },
    "x2": {
      "value": 2.5,
      "unit": "m"
    },
    "v2": {
      "value": -0.05,
      "unit": "m/s"
    },
    "a2": {
      "value": -0.03,
      "unit": "m/s^2"
    },
    "m3": {
      "value": 7.2,
      "unit": "kg"
    },
    "x3": {
      "value": 4.1,
      "unit": "m"
    },
    "v3": {
      "value": 0.15,
      "unit": "m/s"
    },
    "a3": {
      "value": 0.01,
      "unit": "m/s^2"
    },
    "a_cm": {
      "value": "NaN",
      "unit": "m/s^2"
    }
  }
}
```
Validation Result: {'valid': True, 'unknown_var': 'a_cm'}
Call 2 Completed----------------------------------------------------------------------------

import math

def calculate_center_of_mass_1d(masses: list[float], positions: list[float]) -> float:
    if len(masses) != len(positions):
        raise ValueError("Masses and positions lists must have the same length.")
    total_mass = sum(masses)
    if total_mass == 0:
        return 0.0
    mass_moment = sum(m * p for m, p in zip(masses, positions))
    return mass_moment / total_mass

def calculate_com_velocity_1d(masses: list[float], velocities: list[float]) -> float:
    if len(masses) != len(velocities):
        raise ValueError("Masses and velocities lists must have the same length.")
    total_mass = sum(masses)
    if total_mass == 0:
        return 0.0
    total_momentum = sum(m * v for m, v in zip(masses, velocities))
    return total_momentum / total_mass

def calculate_com_acceleration_1d(masses: list[float], accelerations: list[float]) -> float:
    if len(masses) != len(accelerations):
        raise ValueError("Masses and accelerations lists must have the same length.")
    total_mass = sum(masses)
    if total_mass == 0:
        return 0.0
    total_force = sum(m * a for m, a in zip(masses, accelerations))
    return total_force / total_mass

def solve():
    try:
        # Define known variables
        m1 = 5.5
        x1 = 0.8
        v1 = 0.3
        a1 = 0.08
        m2 = 12.0
        x2 = 2.5
        v2 = -0.05
        a2 = -0.03
        m3 = 7.2
        x3 = 4.1
        v3 = 0.15
        a3 = 0.01

        # Prepare lists for the formula
        masses = [m1, m2, m3]
        accelerations = [a1, a2, a3]

        # Use the provided formula function to calculate the acceleration of the center of mass
        a_cm = calculate_com_acceleration_1d(masses, accelerations)

        # Return the computed answer
        return a_cm
    except Exception as e:
        return None
Execution and Validation Result: {'valid': True, 'result': 0.006153846153846155}


==========================================================================================================================================
TEST 5A

```json
{
  "word_problem": "A uniform, slender rod of mass 5.0 kg and length 2.0 m is pivoted at one end. It is released from rest in a horizontal position. Assuming the acceleration due to gravity is 9.81 m/s\u00b2, what is the initial linear acceleration of the free end of the rod?",     
  "formula_ids": [
    "10_J",
    "10_N",
    "10_O",
    "8_D"
  ],
  "variables": {
    "mass": {
      "value": 5.0,
      "unit": "kg"
    },
    "length": {
      "value": 2.0,
      "unit": "m"
    },
    "gravity": {
      "value": 9.81,
      "unit": "m/s\u00b2"
    },
    "a_tip": {
      "value": "NaN",
      "unit": "m/s\u00b2"
    }
  }
}
```
Validation Result: {'valid': True, 'unknown_var': 'a_tip'}
Call 2 Completed----------------------------------------------------------------------------

import math

def calculate_inertia_rod_end(mass: float, length: float) -> float:
    return (1 / 3) * mass * length**2

def calculate_torque_magnitude(force_magnitude: float, lever_arm: float, angle_degrees: float) -> float:
    angle_radians = math.radians(angle_degrees)
    return lever_arm * force_magnitude * math.sin(angle_radians)

def calculate_angular_acceleration_from_torque(net_torque: float, moment_of_inertia: float) -> float:
    if moment_of_inertia == 0:
        return float('inf')
    return net_torque / moment_of_inertia

def calculate_tangential_acceleration(radius: float, angular_acceleration: float) -> float:
    return radius * angular_acceleration

def solve():
    try:
        # Define known variables
        mass = 5.0
        length = 2.0
        gravity = 9.81

        # Step 1: Calculate the moment of inertia of the rod about the pivot (one end)
        # Using formula_id "10_J"
        moment_of_inertia = calculate_inertia_rod_end(mass=mass, length=length)

        # Step 2: Calculate the torque due to gravity
        # The force due to gravity acts at the center of mass (L/2 from the pivot).
        # The rod is released from a horizontal position, so the angle between the lever arm and force is 90 degrees.
        force_gravity = mass * gravity
        lever_arm_to_cm = length / 2

        # Using formula_id "10_N"
        net_torque = calculate_torque_magnitude(force_magnitude=force_gravity, lever_arm=lever_arm_to_cm, angle_degrees=90.0)

        # Step 3: Calculate the angular acceleration of the rod
        # Using formula_id "10_O"
        angular_acceleration = calculate_angular_acceleration_from_torque(net_torque=net_torque, moment_of_inertia=moment_of_inertia)        

        # Step 4: Calculate the initial linear acceleration of the free end of the rod
        # The free end is at a distance 'length' from the pivot.
        # Using formula_id "8_D"
        a_tip = calculate_tangential_acceleration(radius=length, angular_acceleration=angular_acceleration)

        # Return the computed answer
        return a_tip
    except Exception as e:
        return None
Execution and Validation Result: {'valid': True, 'result': 14.715000000000003}
Call 3 Completed----------------------------------------------------------------------------



==========================================================================================================================================
TEST 5B

{
  "word_problem": "A solid sphere, resembling a small bowling ball, with a mass of 5.0 kg and a radius of 0.15 meters, is released from rest at the top of an inclined ramp. The ramp makes an angle of 30.0 degrees with the horizontal. Assuming the sphere rolls without slipping and the acceleration due to gravity is 9.81 m/s², what is the linear acceleration of the sphere's center of mass as it rolls down the ramp?",     
  "formula_ids": [
    "10_D",
    "5_A",
    "10_O",
    "10_N"
  ],
  "variables": {
    "mass": {
      "value": 5.0,
      "unit": "kg"
    },
    "radius": {
      "value": 0.15,
      "unit": "m"
    },
    "incline_angle": {
      "value": 30.0,
      "unit": "degree"
    },
    "gravitational_acceleration": {
      "value": 9.81,
      "unit": "m/s\u00b2"
    },
    "linear_acceleration_com": {
      "value": "NaN",
      "unit": "m/s\u00b2"
    }
  }
}
```
Validation Result: {'valid': True, 'unknown_var': 'linear_acceleration_com'}
Call 2 Completed----------------------------------------------------------------------------

```python
import math
# import numpy as np  # only if needed

# As-it-is Copied functions from available_formulas based on the given formula_ids
def calculate_inertia_solid_sphere(mass: float, radius: float) -> float:
    return (2 / 5) * mass * radius**2

def calculate_net_force(mass: float, acceleration: float) -> float:
    return mass * acceleration

def calculate_angular_acceleration_from_torque(net_torque: float, moment_of_inertia: float) -> float:
    if moment_of_inertia == 0:
        return float('inf')
    return net_torque / moment_of_inertia

def calculate_torque_magnitude(force_magnitude: float, lever_arm: float, angle_degrees: float) -> float:
    angle_radians = math.radians(angle_degrees)
    return lever_arm * force_magnitude * math.sin(angle_radians)


def solve():
    try:
        # Define known variables
        mass = 5.0
        radius = 0.15
        incline_angle_degrees = 30.0
        gravitational_acceleration = 9.81

        # Convert incline angle from degrees to radians for trigonometric functions
        incline_angle_radians = math.radians(incline_angle_degrees)

        # Step 1: Calculate the moment of inertia for the solid sphere.
        # This uses the formula_id "10_D".
        moment_of_inertia_sphere = calculate_inertia_solid_sphere(mass, radius)

        # Step 2: Apply Newton's Second Law for linear and rotational motion,
        # along with the condition for rolling without slipping.
        #
        # For linear motion down the incline (along the x-axis):
        # Net Force = F_gravity_parallel - F_friction = mass * linear_acceleration_com
        # F_gravity_parallel = mass * gravitational_acceleration * sin(incline_angle_radians)
        # So, mass * gravitational_acceleration * sin(incline_angle_radians) - F_friction = mass * linear_acceleration_com (Eq. 1)
        # (This implicitly uses the principle of calculate_net_force (5_A))

        # For rotational motion about the center of mass:
        # Net Torque = F_friction * radius = moment_of_inertia_sphere * angular_acceleration
        # (This implicitly uses the principles of calculate_torque_magnitude (10_N) and
        #  calculate_angular_acceleration_from_torque (10_O))

        # Condition for rolling without slipping:
        # linear_acceleration_com = radius * angular_acceleration
        # So, angular_acceleration = linear_acceleration_com / radius

        # Substitute angular_acceleration into the torque equation:
        # F_friction * radius = moment_of_inertia_sphere * (linear_acceleration_com / radius)
        # Rearrange to find F_friction:
        # F_friction = (moment_of_inertia_sphere * linear_acceleration_com) / (radius**2) (Eq. 2)

        # Substitute F_friction from Eq. 2 into Eq. 1:
        # mass * gravitational_acceleration * sin(incline_angle_radians) - (moment_of_inertia_sphere * linear_acceleration_com) / (radius**2) = mass * linear_acceleration_com

        # Rearrange to solve for linear_acceleration_com:
        # mass * gravitational_acceleration * sin(incline_angle_radians) = mass * linear_acceleration_com + (moment_of_inertia_sphere * linear_acceleration_com) / (radius**2)
        # mass * gravitational_acceleration * sin(incline_angle_radians) = linear_acceleration_com * (mass + moment_of_inertia_sphere / (radius**2))
        # linear_acceleration_com = (mass * gravitational_acceleration * sin(incline_angle_radians)) / (mass + moment_of_inertia_sphere / (radius**2))

        linear_acceleration_com = (mass * gravitational_acceleration * math.sin(incline_angle_radians)) / \
                                  (mass + moment_of_inertia_sphere / (radius**2))

        # Return the computed answer
        return linear_acceleration_com
    except Exception as e:
        return None
```
Execution and Validation Result: {'valid': False, 'error': 'Execution failed: invalid syntax (<string>, line 1)', 'result': None}
Call 3 Completed----------------------------------------------------------------------------



==========================================================================================================================================
TEST 4B

{
  "word_problem": "A carpenter is crafting a unique wooden sculpture composed of three main parts arranged along a central axis. The primary element is a uniform wooden rod with a mass of 5.0 kg and a length of 2.0 m. This rod is positioned such that its center of mass is at the 0.0 m mark on the axis. Attached to one side of the rod is a decorative rectangular wooden plate, which has a mass of 1.5 kg. The center of mass of this plate was previously determined (using principles like those in `calculate_com_rectangular_plate`) to be located at -0.8 m. Further along the rod, a solid hemispherical metal weight, with a mass of 2.5 kg, is attached. The center of mass of this hemisphere was also previously calculated (using principles like those in `calculate_com_solid_hemisphere`) to be at 1.2 m. To ensure the sculpture balances perfectly, the carpenter needs to find the overall x-coordinate of the combined center of mass of this entire system.",
  "formula_ids": [
    "9_A",
    "9_C",
    "9_H"
  ],
  "variables": {
    "mass_rod": {
      "value": 5.0,
      "unit": "kg"
    },
    "length_rod": {
      "value": 2.0,
      "unit": "m"
    },
    "x_position_rod_center": {
      "value": 0.0,
      "unit": "m"
    },
    "mass_point_1": {
      "value": 1.5,
      "unit": "kg"
    },
    "x_position_point_1": {
      "value": -0.8,
      "unit": "m"
    },
    "mass_point_2": {
      "value": 2.5,
      "unit": "kg"
    },
    "x_position_point_2": {
      "value": 1.2,
      "unit": "m"
    },
    "x_coordinate_combined_center_of_mass": {
      "value": "NaN",
      "unit": "m"
    }
  }
}
```
Validation Result: {'valid': True, 'unknown_var': 'x_coordinate_combined_center_of_mass'}
Call 2 Completed----------------------------------------------------------------------------

import math

def calculate_center_of_mass_1d(masses: list[float], positions: list[float]) -> float:
    if len(masses) != len(positions):
        raise ValueError("Masses and positions lists must have the same length.")
    total_mass = sum(masses)
    if total_mass == 0:
        return 0.0
    mass_moment = sum(m * p for m, p in zip(masses, positions))
    return mass_moment / total_mass

def calculate_com_rectangular_plate(base: float, height: float) -> tuple[float, float]:
    return (base / 2, height / 2)

def calculate_com_solid_hemisphere(radius: float) -> float:
    return (3 * radius) / 8

def solve():
    try:
        # Define known variables
        mass_rod = 5.0
        length_rod = 2.0
        x_position_rod_center = 0.0
        mass_point_1 = 1.5
        x_position_point_1 = -0.8
        mass_point_2 = 2.5
        x_position_point_2 = 1.2

        # The problem requires finding the combined center of mass of a system of discrete parts.
        # The center of mass for each part is already given.
        # We can treat each part as a point mass located at its center of mass.

        # Collect all masses
        masses = [mass_rod, mass_point_1, mass_point_2]

        # Collect all corresponding x-coordinates of their centers of mass
        positions = [x_position_rod_center, x_position_point_1, x_position_point_2]

        # Use the calculate_center_of_mass_1d function to find the overall x-coordinate
        x_coordinate_combined_center_of_mass = calculate_center_of_mass_1d(masses, positions)

        return x_coordinate_combined_center_of_mass
    except Exception as e:
        return None
Execution and Validation Result: {'valid': True, 'result': 0.19999999999999998}
Call 3 Completed----------------------------------------------------------------------------

==========================================================================================================================================
TEST 3B

{
  "word_problem": "A high-performance race car is navigating a turn on a flat, dry asphalt track. The turn has a constant radius of 80.0 meters. At a particular instant, the car's linear speed is 35.0 m/s, and it is simultaneously accelerating along the track (tangentially) with an angular acceleration of 0.06 rad/s\u00b2. Calculate the magnitude of the car's total acceleration at this instant.",
  "formula_ids": [
    "8_D",
    "8_E",
    "8_F"
  ],
  "variables": {
    "radius": {
      "value": 80.0,
      "unit": "m"
    },
    "linear_speed": {
      "value": 35.0,
      "unit": "m/s"
    },
    "angular_acceleration": {
      "value": 0.06,
      "unit": "rad/s^2"
    },
    "total_acceleration": {
      "value": "NaN",
      "unit": "m/s^2"
    }
  }
}
```
Validation Result: {'valid': True, 'unknown_var': 'total_acceleration'}
Call 2 Completed----------------------------------------------------------------------------

import math

def calculate_tangential_acceleration(radius: float, angular_acceleration: float) -> float:
    return radius * angular_acceleration

def calculate_centripetal_acceleration(radius: float, linear_speed: float = None, angular_velocity: float = None) -> float:
    if radius == 0:
        return 0.0
    if linear_speed is not None:
        return linear_speed**2 / radius
    elif angular_velocity is not None:
        return angular_velocity**2 * radius
    else:
        raise ValueError("Must provide either linear_speed or angular_velocity")

def calculate_total_acceleration(tangential_acceleration: float, centripetal_acceleration: float) -> float:
    return math.sqrt(tangential_acceleration**2 + centripetal_acceleration**2)

def solve():
    try:
        # Define known variables
        radius = 80.0
        linear_speed = 35.0
        angular_acceleration = 0.06

        # Step 1: Calculate tangential acceleration (a_t) using formula 8_D
        tangential_acceleration = calculate_tangential_acceleration(radius, angular_acceleration)

        # Step 2: Calculate centripetal acceleration (a_r) using formula 8_E
        # We have linear_speed, so we use that variant of the function
        centripetal_acceleration = calculate_centripetal_acceleration(radius=radius, linear_speed=linear_speed)

        # Step 3: Calculate the total acceleration using formula 8_F
        total_acceleration = calculate_total_acceleration(tangential_acceleration, centripetal_acceleration)

        # Return the computed answer
        return total_acceleration
    except Exception as e:
        return None
Execution and Validation Result: {'valid': True, 'result': 16.047200885201132}
Call 3 Completed----------------------------------------------------------------------------

==========================================================================================================================================
TEST 2B

{
  "word_problem": "A constant-power winch pulls a heavy shipping container up a greasy ramp onto a cargo ship, maintaining a steady velocity. The container is pulled for a displacement of 20 meters over a time interval of 45 seconds. During this movement, the force of kinetic friction acting on the container is 1500 N, opposing the motion. The component of the gravitational force acting down the incline, parallel to the ramp, is 3500 N, also opposing the motion. Assuming the winch pulls parallel to the ramp and no pseudo-forces are present, what is the average power delivered by the winch?",
  "formula_ids": [
    "7_H",
    "7_F",
    "7_A"
  ],
  "variables": {
    "Displacement_along_ramp": {
      "value": 20,
      "unit": "m"
    },
    "Time_interval": {
      "value": 45,
      "unit": "s"
    },
    "Force_of_kinetic_friction": {
      "value": 1500,
      "unit": "N"
    },
    "Force_of_gravity_parallel_to_ramp": {
      "value": 3500,
      "unit": "N"
    },
    "Power_delivered_by_winch": {
      "value": "NaN",
      "unit": "W"
    }
  }
}
```
Validation Result: {'valid': True, 'unknown_var': 'Power_delivered_by_winch'}
Call 2 Completed----------------------------------------------------------------------------

import math

def calculate_work_done_constant_force(force_magnitude: float, displacement_magnitude: float, angle_degrees: float) -> float:
    angle_radians = math.radians(angle_degrees)
    return force_magnitude * displacement_magnitude * math.cos(angle_radians)

def calculate_change_in_kinetic_energy(work_conservative: float, work_non_conservative: float, work_pseudo_force: float) -> float:
    return work_conservative + work_non_conservative + work_pseudo_force

def calculate_average_power(work: float, time: float) -> float:
    if time == 0:
        return float('inf')
    return work / time

def solve():
    try:
        # Define known variables
        displacement_along_ramp = 20
        time_interval = 45
        force_of_kinetic_friction = 1500
        force_of_gravity_parallel_to_ramp = 3500

        # The container is moving at a steady velocity, so the net force is zero.
        # The force delivered by the winch must balance the opposing forces (friction and gravity component).
        # Winch pulls parallel to the ramp, opposing forces also act parallel to the ramp.

        # Calculate the total opposing force
        total_opposing_force = force_of_kinetic_friction + force_of_gravity_parallel_to_ramp

        # Since velocity is steady, the force exerted by the winch equals the total opposing force
        force_by_winch = total_opposing_force # N

        # Calculate the work done by the winch
        # The winch pulls parallel to the ramp, and displacement is along the ramp, so the angle is 0 degrees.
        work_done_by_winch = calculate_work_done_constant_force(force_by_winch, displacement_along_ramp, 0) # J

        # Calculate the average power delivered by the winch
        power_delivered_by_winch = calculate_average_power(work_done_by_winch, time_interval) # W

        return power_delivered_by_winch
    except Exception as e:
        return None
Execution and Validation Result: {'valid': True, 'result': 2222.222222222222}
Call 3 Completed----------------------------------------------------------------------------

==========================================================================================================================================
TEST 1B

{
  "word_problem": "An athlete is training with a heavy sled on a horizontal track. The sled, with a mass of 40.0 kg, is connected by a light, inextensible rope over a frictionless pulley to a hanging weight of 8.0 kg. The coefficient of kinetic friction between the sled and the track is 0.35. If the system is to accelerate at 1.5 m/s² and the acceleration due to gravity is 9.81 m/s², what applied force must the athlete exert horizontally on the sled?",
  "formula_ids": [
    "6_A",
    "5_A"
  ],
  "variables": {
    "mass_block_on_floor": {
      "value": 40.0,
      "unit": "kg"
    },
    "hanging_mass": {
      "value": 8.0,
      "unit": "kg"
    },
    "coefficient_of_kinetic_friction": {
      "value": 0.35,
      "unit": "dimensionless"
    },
    "acceleration_due_to_gravity": {
      "value": 9.81,
      "unit": "m/s\u00b2"
    },
    "acceleration_of_system": {
      "value": 1.5,
      "unit": "m/s\u00b2"
    },
    "applied_force": {
      "value": "NaN",
      "unit": "N"
    }
  }
}
```
Validation Result: {'valid': True, 'unknown_var': 'applied_force'}
Call 2 Completed----------------------------------------------------------------------------

import math

def calculate_net_force(mass: float, acceleration: float) -> float:
    return mass * acceleration

def calculate_kinetic_friction(coefficient_of_kinetic_friction: float, normal_force: float) -> float:
    return coefficient_of_kinetic_friction * normal_force

def solve():
    try:
        # Define known variables
        mass_block_on_floor = 40.0
        hanging_mass = 8.0
        coefficient_of_kinetic_friction = 0.35
        acceleration_due_to_gravity = 9.81
        acceleration_of_system = 1.5

        # Step 1: Calculate the normal force on the sled.
        # On a horizontal surface, Normal Force = mass_block_on_floor * acceleration_due_to_gravity
        normal_force_sled = mass_block_on_floor * acceleration_due_to_gravity

        # Step 2: Calculate the kinetic friction force on the sled.
        # F_friction = mu_k * N
        friction_force = calculate_kinetic_friction(coefficient_of_kinetic_friction, normal_force_sled)

        # Step 3: Calculate the tension in the rope.
        # The hanging mass accelerates upwards (assuming the athlete pulls the sled away from the pulley).
        # Forces on hanging mass: Tension (up), Gravity (down)
        # T - hanging_mass * g = hanging_mass * a_system
        # T = hanging_mass * (g + a_system)
        tension = hanging_mass * (acceleration_due_to_gravity + acceleration_of_system)

        # Step 4: Calculate the required net force on the sled.
        # F_net_sled = mass_block_on_floor * a_system
        net_force_sled = calculate_net_force(mass_block_on_floor, acceleration_of_system)

        # Step 5: Calculate the applied force by the athlete.
        # Forces on sled in horizontal direction:
        # F_applied (forward)
        # Tension (backward, pulling towards the pulley)
        # Friction (backward, opposing motion)
        # F_net_sled = F_applied - Tension - Friction
        # F_applied = F_net_sled + Tension + Friction
        applied_force = net_force_sled + tension + friction_force

        return applied_force
    except Exception as e:
        return None
Execution and Validation Result: {'valid': True, 'result': 287.82000000000005}
Call 3 Completed----------------------------------------------------------------------------





